# ZMQ Socket for CFR or IQ-Sample provisioning 

To enable the use of CFR estimates generated by a MultiSync-derived instance in other applications, a TCP socket interface was implemented using ZeroMQ (defined in ./include/zmq\_socket/zmq\_socket.h). This interface facilitates the transfer of numeric data structures from the C++ application to another endpoint, in this case, a Python application executing the MUSIC algorithm. The ```send()``` function is overloaded to handle one-, two-, or three-dimensional datasets, enabling the transmission of single IQ-sample vectors of variable length, sample vectors from multiple channels within a single frame (snapshots), and snapshots from multiple received frames. 

In the C++ implementation, the socket is first initialized, after which the ```send()``` function is invoked with one to three dimensional vectors as input. In the application, socket initialization is performed within the main thread (defined in ./src/main.cc), whereas the actual CFR export is carried out by the ```cfr_export_worker()``` function (defined in ./include/multi\_rx/multi\_rx.h) , which runs in a separate thread.
#### Utilization of a ```ZmqSender``` instance to transmit the CFR corresponding to one frame via a TCP socket
```cpp
// Initialize the ZMQ socket on localhost TCP port 5555
ZmqSender socket("tcp://*:5555");

// 2-dimensional buffer to store the cfr for all channels for a single frame
std::vector<std::vector<std::complex<float>>> cfr(NUM_CHANNELS); 

// ...Receive and synchronize...

// Get the CFR of all synchronizers after a frame was detected
for (unsigned int j = 0; j < NUM_CHANNELS; ++j){
        ms.GetCfr(j, &cfr[j]);                                 
};

// ZMQ Export
socket.send(cfr);
```

Within the Python application, the messages received via the socket are accumulated and stacked along a fourth dimension. This approach minimizes data loss in cases where the message reception rate exceeds the GUI update rate. The complete implementation is contained within the ```pollSocket()``` member function of the ```MusicSpectrum``` class (defined in ./music/music-spectrum.py).

#### Simplified implementation for receiving vectorized datasets from a ```ZmqSender``` instance in Python
```python
# ZMQ socket setup
context = zmq.Context()
socket = context.socket(zmq.PULL)
socket.connect("tcp://localhost:5555")
poller = zmq.Poller()
poller.register(self.socket, zmq.POLLIN)
csi = None

# Drain the socket: collect all messages 
messages = []
while True:
    try:
        msg = socket.recv(zmq.NOBLOCK)
        messages.append(msg)
    except zmq.Again:
        break  # No more messages available

#process all received messages 
all_data = []
for msg in messages:
        # Detect dimensions in Header: 3 x uint32 -> 12 bytes
        n_measurements, num_channels, samples_per_channel = struct.unpack("III", msg[:12])
        
        # Load Data (complex values)
        data = np.frombuffer(msg[12:], dtype=np.complex64)

        # Transform to  (num_channels, samples_per_channel) 
        try:
            reshaped = data.reshape((n_measurements, num_channels, samples_per_channel))
        except ValueError:
            return  # skip invalid reshape

        all_data.append(reshaped)  

# stack along n_measurements axis
stacked = np.concatenate(all_data, axis=0)

# shape : (size, n_arrays, n_rows, n_antennas, subcarriers)
csi = stacked[:, np.newaxis, np.newaxis, :, :]
```
